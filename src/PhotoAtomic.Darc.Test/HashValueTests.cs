using PhotoAtomic.Clooney;
using System.Runtime.Serialization;
using Xunit;

namespace PhotoAtomic.Darc.Test;

/// <summary>
/// Tests for HashValue() extension method generated by HashableGenerator.
/// Verifies hash computation for object graphs including edge cases like
/// circular references and structural differences.
/// </summary>
public class HashValueTests
{
    #region Basic Hash Tests

    [Fact]
    public void HashValue_SameStructureAndValues_ProducesSameHash()
    {
        // Arrange - two separate instances with identical values and structure
        var obj1 = new PersonState
        {
            Name = "Alice",
            Age = 30,
            Score = 95.5m
        };

        var obj2 = new PersonState
        {
            Name = "Alice",
            Age = 30,
            Score = 95.5m
        };

        // Act
        var hash1 = obj1.HashValue();
        var hash2 = obj2.HashValue();

        // Assert - same values and structure should produce same hash
        Assert.Equal(hash1, hash2);
    }

    [Fact]
    public void HashValue_DifferentValues_ProducesDifferentHash()
    {
        // Arrange
        var obj1 = new PersonState
        {
            Name = "Alice",
            Age = 30,
            Score = 95.5m
        };

        var obj2 = new PersonState
        {
            Name = "Bob", // Different value
            Age = 30,
            Score = 95.5m
        };

        // Act
        var hash1 = obj1.HashValue();
        var hash2 = obj2.HashValue();

        // Assert - different values should produce different hash
        Assert.NotEqual(hash1, hash2);
    }

    [Fact]
    public void HashValue_NullObject_ReturnsZero()
    {
        // Arrange
        PersonState? obj = null;

        // Act
        var hash = obj.HashValue();

        // Assert
        Assert.Equal(0, hash);
    }

    #endregion

    #region Structural Difference Tests

    [Fact]
    public void HashValue_SameValuesDifferentStructure_ProducesDifferentHash()
    {
        // Arrange - two objects with same child values but different reference structure
        var sharedChild = new PersonState { Name = "Child", Age = 10, Score = 80m };
        var independentChild1 = new PersonState { Name = "Child", Age = 10, Score = 80m };
        var independentChild2 = new PersonState { Name = "Child", Age = 10, Score = 80m };

        // Graph 1: Root -> Left (sharedChild), Root -> Right (sharedChild) - same instance twice
        var graph1 = new FamilyTree
        {
            Name = "Root",
            LeftChild = sharedChild,
            RightChild = sharedChild // Same reference as LeftChild
        };

        // Graph 2: Root -> Left (independentChild1), Root -> Right (independentChild2) - different instances
        var graph2 = new FamilyTree
        {
            Name = "Root",
            LeftChild = independentChild1,
            RightChild = independentChild2 // Different instance with same values
        };

        // Act
        var hash1 = graph1.HashValue();
        var hash2 = graph2.HashValue();

        // Assert - different structure should produce different hash, even with same values
        Assert.NotEqual(hash1, hash2);
    }

    #endregion

    #region Circular Reference Tests

    [Fact]
    public void HashValue_CircularReference_DoesNotCrash()
    {
        // Arrange - create a circular reference
        var node1 = new LinkedNode { Value = 1 };
        var node2 = new LinkedNode { Value = 2 };
        node1.Next = node2;
        node2.Next = node1; // Circular reference

        // Act & Assert - should not crash or infinite loop
        var hash = node1.HashValue();
        Assert.NotEqual(0, hash);
    }

    [Fact]
    public void HashValue_CircularReferenceSameStructure_ProducesSameHash()
    {
        // Arrange - two identical circular structures
        var node1a = new LinkedNode { Value = 1 };
        var node2a = new LinkedNode { Value = 2 };
        node1a.Next = node2a;
        node2a.Next = node1a;

        var node1b = new LinkedNode { Value = 1 };
        var node2b = new LinkedNode { Value = 2 };
        node1b.Next = node2b;
        node2b.Next = node1b;

        // Act
        var hash1 = node1a.HashValue();
        var hash2 = node1b.HashValue();

        // Assert - same circular structure should produce same hash
        Assert.Equal(hash1, hash2);
    }

    [Fact]
    public void HashValue_SelfReferentialCircle_HandlesCorrectly()
    {
        // Arrange - object references itself
        var node = new LinkedNode { Value = 42 };
        node.Next = node; // Self-reference

        // Act & Assert - should not crash
        var hash = node.HashValue();
        Assert.NotEqual(0, hash);
    }

    [Fact]
    public void HashValue_ComplexCircularGraph_HandlesCorrectly()
    {
        // Arrange - complex circular structure
        var node1 = new TreeNode { Value = 1 };
        var node2 = new TreeNode { Value = 2 };
        var node3 = new TreeNode { Value = 3 };

        node1.Children = new List<TreeNode> { node2, node3 };
        node2.Children = new List<TreeNode> { node3 };
        node3.Children = new List<TreeNode> { node1 }; // Circular back to node1

        // Act & Assert - should not crash
        var hash = node1.HashValue();
        Assert.NotEqual(0, hash);
    }

    #endregion

    #region Collection Tests

    [Fact]
    public void HashValue_WithCollections_IncludesAllElements()
    {
        // Arrange
        var obj1 = new NumberList
        {
            Name = "test",
            Numbers = new List<int> { 1, 2, 3, 4, 5 }
        };

        var obj2 = new NumberList
        {
            Name = "test",
            Numbers = new List<int> { 1, 2, 3, 4, 6 } // Last element different
        };

        // Act
        var hash1 = obj1.HashValue();
        var hash2 = obj2.HashValue();

        // Assert - different collection contents should produce different hash
        Assert.NotEqual(hash1, hash2);
    }

    [Fact]
    public void HashValue_EmptyCollections_HandlesCorrectly()
    {
        // Arrange
        var obj1 = new NumberList { Name = "test", Numbers = new List<int>() };
        var obj2 = new NumberList { Name = "test", Numbers = new List<int>() };
        var obj3 = new NumberList { Name = "test", Numbers = new List<int> { 1 } };

        // Act
        var hash1 = obj1.HashValue();
        var hash2 = obj2.HashValue();
        var hash3 = obj3.HashValue();

        // Assert
        Assert.Equal(hash1, hash2); // Same empty collections
        Assert.NotEqual(hash1, hash3); // Empty vs non-empty
    }

    [Fact]
    public void HashValue_DifferentOrder_SameStructure_ProducesDifferentHash()
    {
        // Arrange - collections with same elements but different order
        var obj1 = new NumberList
        {
            Name = "test",
            Numbers = new List<int> { 1, 2, 3 }
        };

        var obj2 = new NumberList
        {
            Name = "test",
            Numbers = new List<int> { 3, 2, 1 } // Different order
        };

        // Act
        var hash1 = obj1.HashValue();
        var hash2 = obj2.HashValue();

        // Assert - different order should produce different hash
        Assert.NotEqual(hash1, hash2);
    }

    #endregion

    #region Nested Object Tests

    [Fact]
    public void HashValue_WithNestedObjects_IncludesNestedValues()
    {
        // Arrange
        var obj1 = new FamilyTree
        {
            Name = "Root",
            LeftChild = new PersonState { Name = "Alice", Age = 10, Score = 85m },
            RightChild = new PersonState { Name = "Bob", Age = 12, Score = 90m }
        };

        var obj2 = new FamilyTree
        {
            Name = "Root",
            LeftChild = new PersonState { Name = "Alice", Age = 10, Score = 85m },
            RightChild = new PersonState { Name = "Bob", Age = 12, Score = 91m } // Different nested value
        };

        // Act
        var hash1 = obj1.HashValue();
        var hash2 = obj2.HashValue();

        // Assert - different nested values should produce different hash
        Assert.NotEqual(hash1, hash2);
    }

    [Fact]
    public void HashValue_NullValues_HandlesCorrectly()
    {
        // Arrange
        var obj1 = new FamilyTree { Name = "Root", LeftChild = null, RightChild = null };
        var obj2 = new FamilyTree { Name = "Root", LeftChild = null, RightChild = null };
        var obj3 = new FamilyTree
        {
            Name = "Root",
            LeftChild = null,
            RightChild = new PersonState { Name = "Child", Age = 0 } // Not null
        };

        // Act
        var hash1 = obj1.HashValue();
        var hash2 = obj2.HashValue();
        var hash3 = obj3.HashValue();

        // Assert
        Assert.Equal(hash1, hash2); // Same nulls
        Assert.NotEqual(hash1, hash3); // Null vs non-null
    }

    #endregion

    #region Context Tests

    [Fact]
    public void HashValue_WithHashContext_TracksReferences()
    {
        // Arrange
        var sharedChild = new PersonState { Name = "Shared", Age = 10 };
        var graph = new FamilyTree
        {
            Name = "Root",
            LeftChild = sharedChild,
            RightChild = sharedChild // Same reference twice
        };

        var context = new HashContext();

        // Act
        var hash = graph.HashValue(context);

        // Assert - should track that sharedChild was visited
        Assert.True(context.IsVisited(sharedChild));
    }

    [Fact]
    public void HashValue_ComplexGraph_ProducesConsistentHash()
    {
        // Arrange - complex graph with multiple levels
        var leaf1 = new PersonState { Name = "Leaf1", Age = 5 };
        var leaf2 = new PersonState { Name = "Leaf2", Age = 6 };
        var leaf3 = new PersonState { Name = "Leaf3", Age = 7 };

        var graph = new FamilyTree
        {
            Name = "Root",
            LeftChild = new PersonState
            {
                Name = "Branch1"
            },
            RightChild = new PersonState
            {
                Name = "Branch2"
            }
        };

        // Act - compute hash multiple times
        var hash1 = graph.HashValue();
        var hash2 = graph.HashValue();

        // Assert - should be consistent
        Assert.Equal(hash1, hash2);
    }

    #endregion

    #region Polymorphism Tests

    [Fact]
    public void HashValue_PolymorphicProperty_WithDifferentDerivedTypes_ProducesDifferentHash()
    {
        // Arrange - same base type property but different derived instances
        var obj1 = new VehicleContainer
        {
            Vehicle = new Car { Brand = "Toyota", Doors = 4 }
        };

        var obj2 = new VehicleContainer
        {
            Vehicle = new Motorcycle { Brand = "Honda", HasSidecar = false }
        };

        // Act
        var hash1 = obj1.HashValue();
        var hash2 = obj2.HashValue();

        // Assert - different derived types should produce different hash
        Assert.NotEqual(hash1, hash2);
    }

    [Fact]
    public void HashValue_PolymorphicProperty_SameDerivedType_SameValues_ProducesSameHash()
    {
        // Arrange
        var obj1 = new VehicleContainer
        {
            Vehicle = new Car { Brand = "Toyota", Doors = 4 }
        };

        var obj2 = new VehicleContainer
        {
            Vehicle = new Car { Brand = "Toyota", Doors = 4 }
        };

        // Act
        var hash1 = obj1.HashValue();
        var hash2 = obj2.HashValue();

        // Assert - same derived type with same values should produce same hash
        Assert.Equal(hash1, hash2);
    }

    [Fact]
    public void HashValue_MultiLevelInheritance_HandlesCorrectly()
    {
        // Arrange
        var obj1 = new VehicleContainer
        {
            Vehicle = new SportsCar { Brand = "Ferrari", Doors = 2, TopSpeed = 320 }
        };

        var obj2 = new VehicleContainer
        {
            Vehicle = new SportsCar { Brand = "Ferrari", Doors = 2, TopSpeed = 320 }
        };

        var obj3 = new VehicleContainer
        {
            Vehicle = new SportsCar { Brand = "Ferrari", Doors = 2, TopSpeed = 300 }
        };

        // Act
        var hash1 = obj1.HashValue();
        var hash2 = obj2.HashValue();
        var hash3 = obj3.HashValue();

        // Assert
        Assert.Equal(hash1, hash2); // Same values
        Assert.NotEqual(hash1, hash3); // Different value in derived property
    }

    #endregion

    #region Known Types Tests

    // Note: KnownType tests removed as they require System.Runtime.Serialization assembly reference
    // The generator supports them, but for unit tests we use concrete types instead

    #endregion

    #region Skip Hash Attribute Tests

    [Fact]
    public void HashValue_WithSkipHashAttribute_IgnoresProperty()
    {
        // Arrange
        var obj1 = new CachedData
        {
            ImportantValue = 42,
            CacheTimestamp = DateTime.UtcNow // This should be ignored
        };

        var obj2 = new CachedData
        {
            ImportantValue = 42,
            CacheTimestamp = DateTime.UtcNow.AddDays(10) // Different but should be ignored
        };

        // Act
        var hash1 = obj1.HashValue();
        var hash2 = obj2.HashValue();

        // Assert - should produce same hash despite different CacheTimestamp
        Assert.Equal(hash1, hash2);
    }

    #endregion

    #region Deep Nesting Tests

    [Fact]
    public void HashValue_DeepNesting_HandlesCorrectly()
    {
        // Arrange - deeply nested structure
        TreeNode CreateNestedNodes(int depth, int value)
        {
            if (depth == 0)
                return new TreeNode { Value = value };

            return new TreeNode
            {
                Value = value,
                Children = new List<TreeNode>
                {
                    CreateNestedNodes(depth - 1, value * 10)
                }
            };
        }

        var obj1 = CreateNestedNodes(10, 1); // 10 levels deep
        var obj2 = CreateNestedNodes(10, 1);

        // Act
        var hash1 = obj1.HashValue();
        var hash2 = obj2.HashValue();

        // Assert - same deep structure should produce same hash
        Assert.Equal(hash1, hash2);
    }

    #endregion
}

#region Test Model Classes

// Root types - these are used as entry points in tests
[Hashable]
[Diffable]
public class PersonState
{
    public string? Name { get; set; }
    public int Age { get; set; }
    public decimal Score { get; set; }
}

[Hashable]
[Diffable]
public class FamilyTree
{
    public string? Name { get; set; }
    public PersonState? LeftChild { get; set; }
    public PersonState? RightChild { get; set; }
}

[Hashable]
[Diffable]
public class LinkedNode
{
    public int Value { get; set; }
    public LinkedNode? Next { get; set; }
}

[Hashable]
[Diffable]
public class TreeNode
{
    public int Value { get; set; }
    public List<TreeNode>? Children { get; set; }
}

[Hashable]
[Diffable]
public class NumberList
{
    public string? Name { get; set; }
    public List<int>? Numbers { get; set; }
}

// Polymorphic hierarchy - only mark the root container and abstract base
// Derived types are discovered automatically by the generator!
[Hashable]
[Diffable]
public abstract class Vehicle
{
    public string? Brand { get; set; }
}

// NO attributes needed - discovered automatically from Vehicle!
public class Car : Vehicle
{
    public int Doors { get; set; }
}

public class Motorcycle : Vehicle
{
    public bool HasSidecar { get; set; }
}

public class SportsCar : Car
{
    public int TopSpeed { get; set; }
}

[Hashable]
[Diffable]
public class VehicleContainer
{
    public Vehicle? Vehicle { get; set; }
}

[Hashable]
[Diffable]
public class CachedData
{
    public int ImportantValue { get; set; }

    [SkipHash]
    [SkipDiff]
    public DateTime CacheTimestamp { get; set; }
}

#endregion

