using PhotoAtomic.Clooney;
using System;
using System.Collections.Generic;
using System.Linq;
using Xunit;

namespace PhotoAtomic.Darc.Test;

/// <summary>
/// Tests for Diff() extension method generated by DiffableGenerator.
/// Verifies difference detection for object graphs including edge cases like
/// circular references, collections, and structural differences.
/// </summary>
public class DiffTests
{
    #region Basic Diff Tests

    [Fact]
    public void Diff_SameObject_ReturnsNoDifferences()
    {
        // Arrange
        var obj = new PersonState
        {
            Name = "Alice",
            Age = 30,
            Score = 95.5m
        };

        // Act
        var diffs = obj.Diff(obj).ToList();

        // Assert - same reference should have no differences
        Assert.Empty(diffs);
    }

    [Fact]
    public void Diff_IdenticalValues_ReturnsNoDifferences()
    {
        // Arrange
        var obj1 = new PersonState
        {
            Name = "Alice",
            Age = 30,
            Score = 95.5m
        };

        var obj2 = new PersonState
        {
            Name = "Alice",
            Age = 30,
            Score = 95.5m
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert - identical values should have no differences
        Assert.Empty(diffs);
    }

    [Fact]
    public void Diff_DifferentValueTypeProperty_ReportsDifference()
    {
        // Arrange
        var obj1 = new PersonState
        {
            Name = "Alice",
            Age = 30,
            Score = 95.5m
        };

        var obj2 = new PersonState
        {
            Name = "Alice",
            Age = 31, // Different age
            Score = 95.5m
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Single(diffs);
        var diff = diffs[0];
        Assert.IsType<ValueNode>(diff.Leaf);
        var valueNode = (ValueNode)diff.Leaf;
        Assert.Equal("Age", valueNode.PropertyName);
        Assert.Equal(30, valueNode.CurrentValue);
        Assert.Equal(31, valueNode.OtherValue);
    }

    [Fact]
    public void Diff_DifferentStringProperty_ReportsDifference()
    {
        // Arrange
        var obj1 = new PersonState
        {
            Name = "Alice",
            Age = 30,
            Score = 95.5m
        };

        var obj2 = new PersonState
        {
            Name = "Bob", // Different name
            Age = 30,
            Score = 95.5m
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Single(diffs);
        var diff = diffs[0];
        Assert.IsType<ValueNode>(diff.Leaf);
        var valueNode = (ValueNode)diff.Leaf;
        Assert.Equal("Name", valueNode.PropertyName);
        Assert.Equal("Alice", valueNode.CurrentValue);
        Assert.Equal("Bob", valueNode.OtherValue);
    }

    [Fact]
    public void Diff_MultipleDifferentProperties_ReportsAllDifferences()
    {
        // Arrange
        var obj1 = new PersonState
        {
            Name = "Alice",
            Age = 30,
            Score = 95.5m
        };

        var obj2 = new PersonState
        {
            Name = "Bob",    // Different
            Age = 31,        // Different
            Score = 95.5m
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert - should report both differences
        Assert.Equal(2, diffs.Count);
        Assert.Contains(diffs, d => d.Leaf is ValueNode vn && vn.PropertyName == "Name");
        Assert.Contains(diffs, d => d.Leaf is ValueNode vn && vn.PropertyName == "Age");
    }

    [Fact]
    public void Diff_NullToNonNull_ReportsDifference()
    {
        // Arrange
        PersonState? obj1 = null;
        var obj2 = new PersonState { Name = "Alice", Age = 30, Score = 95.5m };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Single(diffs);
        var diff = diffs[0];
        Assert.IsType<ValueNode>(diff.Leaf);
        var valueNode = (ValueNode)diff.Leaf;
        Assert.Null(valueNode.CurrentValue);
        Assert.NotNull(valueNode.OtherValue);
    }

    [Fact]
    public void Diff_NonNullToNull_ReportsDifference()
    {
        // Arrange
        var obj1 = new PersonState { Name = "Alice", Age = 30, Score = 95.5m };
        PersonState? obj2 = null;

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Single(diffs);
        var diff = diffs[0];
        Assert.IsType<ValueNode>(diff.Leaf);
        var valueNode = (ValueNode)diff.Leaf;
        Assert.NotNull(valueNode.CurrentValue);
        Assert.Null(valueNode.OtherValue);
    }

    [Fact]
    public void Diff_BothNull_ReturnsNoDifferences()
    {
        // Arrange
        PersonState? obj1 = null;
        PersonState? obj2 = null;

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Empty(diffs);
    }

    #endregion

    #region Nested Object Diff Tests

    [Fact]
    public void Diff_NestedObjects_IdenticalValues_ReturnsNoDifferences()
    {
        // Arrange
        var obj1 = new FamilyTree
        {
            Name = "Root",
            LeftChild = new PersonState { Name = "Alice", Age = 10, Score = 85m },
            RightChild = new PersonState { Name = "Bob", Age = 12, Score = 90m }
        };

        var obj2 = new FamilyTree
        {
            Name = "Root",
            LeftChild = new PersonState { Name = "Alice", Age = 10, Score = 85m },
            RightChild = new PersonState { Name = "Bob", Age = 12, Score = 90m }
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Empty(diffs);
    }

    [Fact]
    public void Diff_NestedObject_DifferentProperty_ReportsDifference()
    {
        // Arrange
        var obj1 = new FamilyTree
        {
            Name = "Root",
            LeftChild = new PersonState { Name = "Alice", Age = 10, Score = 85m },
            RightChild = new PersonState { Name = "Bob", Age = 12, Score = 90m }
        };

        var obj2 = new FamilyTree
        {
            Name = "Root",
            LeftChild = new PersonState { Name = "Alice", Age = 10, Score = 85m },
            RightChild = new PersonState { Name = "Bob", Age = 13, Score = 90m } // Different age
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Single(diffs);
        var diff = diffs[0];
        
        // Check the path
        var path = diff.GetPath().ToList();
        Assert.True(path.Count >= 2);
        Assert.IsType<ReferenceNode>(path[0]);
        Assert.Equal("RightChild", ((ReferenceNode)path[0]).PropertyName);
        
        Assert.IsType<ValueNode>(diff.Leaf);
        var valueNode = (ValueNode)diff.Leaf;
        Assert.Equal("Age", valueNode.PropertyName);
        Assert.Equal(12, valueNode.CurrentValue);
        Assert.Equal(13, valueNode.OtherValue);
    }

    [Fact]
    public void Diff_NullNestedObject_ReportsDifference()
    {
        // Arrange
        var obj1 = new FamilyTree
        {
            Name = "Root",
            LeftChild = new PersonState { Name = "Alice", Age = 10, Score = 85m },
            RightChild = null
        };

        var obj2 = new FamilyTree
        {
            Name = "Root",
            LeftChild = new PersonState { Name = "Alice", Age = 10, Score = 85m },
            RightChild = new PersonState { Name = "Bob", Age = 12, Score = 90m }
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Single(diffs);
        var diff = diffs[0];
        var path = diff.GetPath().ToList();
        Assert.Contains(path, n => n is ReferenceNode rn && rn.PropertyName == "RightChild");
    }

    [Fact]
    public void Diff_DeeplyNestedObjects_FindsDifferences()
    {
        // Arrange - deeply nested structure
        var obj1 = new TreeNode
        {
            Value = 1,
            Children = new List<TreeNode>
            {
                new TreeNode
                {
                    Value = 2,
                    Children = new List<TreeNode>
                    {
                        new TreeNode { Value = 3 }
                    }
                }
            }
        };

        var obj2 = new TreeNode
        {
            Value = 1,
            Children = new List<TreeNode>
            {
                new TreeNode
                {
                    Value = 2,
                    Children = new List<TreeNode>
                    {
                        new TreeNode { Value = 4 } // Different value at depth 3
                    }
                }
            }
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Single(diffs);
        var diff = diffs[0];
        Assert.IsType<ValueNode>(diff.Leaf);
        var valueNode = (ValueNode)diff.Leaf;
        Assert.Equal("Value", valueNode.PropertyName);
        Assert.Equal(3, valueNode.CurrentValue);
        Assert.Equal(4, valueNode.OtherValue);
    }

    #endregion

    #region Collection Diff Tests

    [Fact]
    public void Diff_IdenticalCollections_ReturnsNoDifferences()
    {
        // Arrange
        var obj1 = new NumberList
        {
            Name = "test",
            Numbers = new List<int> { 1, 2, 3, 4, 5 }
        };

        var obj2 = new NumberList
        {
            Name = "test",
            Numbers = new List<int> { 1, 2, 3, 4, 5 }
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Empty(diffs);
    }

    [Fact]
    public void Diff_DifferentCollectionSize_ReportsSizeDifference()
    {
        // Arrange
        var obj1 = new NumberList
        {
            Name = "test",
            Numbers = new List<int> { 1, 2, 3 }
        };

        var obj2 = new NumberList
        {
            Name = "test",
            Numbers = new List<int> { 1, 2, 3, 4, 5 }
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.NotEmpty(diffs);
        Assert.Contains(diffs, d => d.Leaf is CollectionSizeNode csn && csn.CurrentSize == 3 && csn.OtherSize == 5);
    }

    [Fact]
    public void Diff_DifferentCollectionElement_ReportsElementDifference()
    {
        // Arrange
        var obj1 = new NumberList
        {
            Name = "test",
            Numbers = new List<int> { 1, 2, 3, 4, 5 }
        };

        var obj2 = new NumberList
        {
            Name = "test",
            Numbers = new List<int> { 1, 2, 99, 4, 5 } // Element at index 2 is different
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Single(diffs);
        var diff = diffs[0];
        
        // Check path contains collection element node
        var path = diff.GetPath().ToList();
        Assert.Contains(path, n => n is CollectionElementNode cen && cen.IndexOrKey.Equals(2));
        
        Assert.IsType<ValueNode>(diff.Leaf);
        var valueNode = (ValueNode)diff.Leaf;
        Assert.Equal(3, valueNode.CurrentValue);
        Assert.Equal(99, valueNode.OtherValue);
    }

    [Fact]
    public void Diff_DifferentCollectionOrder_ReportsDifferences()
    {
        // Arrange - same elements, different order
        var obj1 = new NumberList
        {
            Name = "test",
            Numbers = new List<int> { 1, 2, 3 }
        };

        var obj2 = new NumberList
        {
            Name = "test",
            Numbers = new List<int> { 3, 2, 1 } // Different order
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert - should report differences at indices 0 and 2
        Assert.Equal(2, diffs.Count);
    }

    [Fact]
    public void Diff_EmptyCollections_ReturnsNoDifferences()
    {
        // Arrange
        var obj1 = new NumberList { Name = "test", Numbers = new List<int>() };
        var obj2 = new NumberList { Name = "test", Numbers = new List<int>() };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Empty(diffs);
    }

    [Fact]
    public void Diff_EmptyToNonEmpty_ReportsSizeDifference()
    {
        // Arrange
        var obj1 = new NumberList { Name = "test", Numbers = new List<int>() };
        var obj2 = new NumberList { Name = "test", Numbers = new List<int> { 1, 2, 3 } };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.NotEmpty(diffs);
        Assert.Contains(diffs, d => d.Leaf is CollectionSizeNode csn && csn.CurrentSize == 0 && csn.OtherSize == 3);
    }

    [Fact]
    public void Diff_CollectionOfObjects_FindsDifferences()
    {
        // Arrange
        var obj1 = new TreeNode
        {
            Value = 1,
            Children = new List<TreeNode>
            {
                new TreeNode { Value = 10 },
                new TreeNode { Value = 20 },
                new TreeNode { Value = 30 }
            }
        };

        var obj2 = new TreeNode
        {
            Value = 1,
            Children = new List<TreeNode>
            {
                new TreeNode { Value = 10 },
                new TreeNode { Value = 25 }, // Different value
                new TreeNode { Value = 30 }
            }
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Single(diffs);
        var diff = diffs[0];
        var path = diff.GetPath().ToList();
        
        // Should have CollectionElementNode for index 1
        Assert.Contains(path, n => n is CollectionElementNode cen && cen.IndexOrKey.Equals(1));
        
        Assert.IsType<ValueNode>(diff.Leaf);
        var valueNode = (ValueNode)diff.Leaf;
        Assert.Equal(20, valueNode.CurrentValue);
        Assert.Equal(25, valueNode.OtherValue);
    }

    [Fact]
    public void Diff_NullCollection_ReportsDifference()
    {
        // Arrange
        var obj1 = new NumberList { Name = "test", Numbers = null };
        var obj2 = new NumberList { Name = "test", Numbers = new List<int> { 1, 2, 3 } };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.NotEmpty(diffs);
    }

    #endregion

    #region Circular Reference Tests

    [Fact]
    public void Diff_CircularReference_IdenticalStructure_ReturnsNoDifferences()
    {
        // Arrange - identical circular structures
        var node1a = new LinkedNode { Value = 1 };
        var node2a = new LinkedNode { Value = 2 };
        node1a.Next = node2a;
        node2a.Next = node1a;

        var node1b = new LinkedNode { Value = 1 };
        var node2b = new LinkedNode { Value = 2 };
        node1b.Next = node2b;
        node2b.Next = node1b;

        // Act
        var diffs = node1a.Diff(node1b).ToList();

        // Assert
        Assert.Empty(diffs);
    }

    [Fact]
    public void Diff_CircularReference_DifferentValue_ReportsDifference()
    {
        // Arrange - circular structures with different value
        var node1a = new LinkedNode { Value = 1 };
        var node2a = new LinkedNode { Value = 2 };
        node1a.Next = node2a;
        node2a.Next = node1a;

        var node1b = new LinkedNode { Value = 1 };
        var node2b = new LinkedNode { Value = 3 }; // Different value
        node1b.Next = node2b;
        node2b.Next = node1b;

        // Act
        var diffs = node1a.Diff(node1b).ToList();

        // Assert
        Assert.Single(diffs);
        var diff = diffs[0];
        Assert.IsType<ValueNode>(diff.Leaf);
        var valueNode = (ValueNode)diff.Leaf;
        Assert.Equal("Value", valueNode.PropertyName);
        Assert.Equal(2, valueNode.CurrentValue);
        Assert.Equal(3, valueNode.OtherValue);
    }

    [Fact]
    public void Diff_SelfReferentialCircle_IdenticalStructure_ReturnsNoDifferences()
    {
        // Arrange - objects reference themselves
        var node1 = new LinkedNode { Value = 42 };
        node1.Next = node1;

        var node2 = new LinkedNode { Value = 42 };
        node2.Next = node2;

        // Act
        var diffs = node1.Diff(node2).ToList();

        // Assert
        Assert.Empty(diffs);
    }

    [Fact]
    public void Diff_ComplexCircularGraph_IdenticalStructure_ReturnsNoDifferences()
    {
        // Arrange - complex circular structures
        var node1a = new TreeNode { Value = 1 };
        var node2a = new TreeNode { Value = 2 };
        var node3a = new TreeNode { Value = 3 };
        node1a.Children = new List<TreeNode> { node2a, node3a };
        node2a.Children = new List<TreeNode> { node3a };
        node3a.Children = new List<TreeNode> { node1a };

        var node1b = new TreeNode { Value = 1 };
        var node2b = new TreeNode { Value = 2 };
        var node3b = new TreeNode { Value = 3 };
        node1b.Children = new List<TreeNode> { node2b, node3b };
        node2b.Children = new List<TreeNode> { node3b };
        node3b.Children = new List<TreeNode> { node1b };

        // Act
        var diffs = node1a.Diff(node1b).ToList();

        // Assert
        Assert.Empty(diffs);
    }

    [Fact]
    public void Diff_CircularReference_DifferentStructure_ThrowsOrReportsDifference()
    {
        // Arrange - different circular structures
        var node1a = new LinkedNode { Value = 1 };
        var node2a = new LinkedNode { Value = 2 };
        var node3a = new LinkedNode { Value = 3 };
        node1a.Next = node2a;
        node2a.Next = node1a; // Points back to node1a

        var node1b = new LinkedNode { Value = 1 };
        var node2b = new LinkedNode { Value = 2 };
        var node3b = new LinkedNode { Value = 3 };
        node1b.Next = node2b;
        node2b.Next = node3b; // Points to node3b instead of node1b
        node3b.Next = node1b; // Creates a longer cycle

        // Act & Assert
        // This should either throw StructuralDifferenceException or report circular reference difference
        var exception = Record.Exception(() =>
        {
            var diffs = node1a.Diff(node1b).ToList();
            
            // If no exception, should have reported a difference
            if (diffs.Count == 0)
            {
                Assert.Fail("Expected differences for structurally different circular references");
            }
        });

        // Accept either exception or difference report
        Assert.True(exception == null || exception is StructuralDifferenceException);
    }

    #endregion

    #region Structural Difference Tests

    [Fact]
    public void Diff_SharedReference_SameStructure_ReturnsNoDifferences()
    {
        // Arrange - both graphs share references in the same way
        var sharedChild = new PersonState { Name = "Shared", Age = 10, Score = 80m };
        var graph1 = new FamilyTree
        {
            Name = "Root",
            LeftChild = sharedChild,
            RightChild = sharedChild // Same reference twice
        };

        var sharedChild2 = new PersonState { Name = "Shared", Age = 10, Score = 80m };
        var graph2 = new FamilyTree
        {
            Name = "Root",
            LeftChild = sharedChild2,
            RightChild = sharedChild2 // Same reference twice
        };

        // Act
        var diffs = graph1.Diff(graph2).ToList();

        // Assert
        Assert.Empty(diffs);
    }

    [Fact]
    public void Diff_SharedVsIndependent_DifferentStructure_ThrowsOrReportsDifference()
    {
        // Arrange - different reference structures
        var sharedChild = new PersonState { Name = "Child", Age = 10, Score = 80m };
        var graph1 = new FamilyTree
        {
            Name = "Root",
            LeftChild = sharedChild,
            RightChild = sharedChild // Same instance twice
        };

        var graph2 = new FamilyTree
        {
            Name = "Root",
            LeftChild = new PersonState { Name = "Child", Age = 10, Score = 80m },
            RightChild = new PersonState { Name = "Child", Age = 10, Score = 80m } // Different instances
        };

        // Act & Assert
        var exception = Record.Exception(() =>
        {
            var diffs = graph1.Diff(graph2).ToList();
            
            // If no exception is thrown, we expect structural differences to be reported somehow
            // (The implementation might handle this differently)
        });

        // This test documents the behavior - structural differences might throw or be reported
        // Adjust based on actual implementation behavior
    }

    #endregion

    #region Polymorphism Tests

    [Fact]
    public void Diff_PolymorphicProperty_SameDerivedType_IdenticalValues_ReturnsNoDifferences()
    {
        // Arrange
        var obj1 = new VehicleContainer
        {
            Vehicle = new Car { Brand = "Toyota", Doors = 4 }
        };

        var obj2 = new VehicleContainer
        {
            Vehicle = new Car { Brand = "Toyota", Doors = 4 }
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Empty(diffs);
    }

    [Fact]
    public void Diff_PolymorphicProperty_SameDerivedType_DifferentValues_ReportsDifference()
    {
        // Arrange
        var obj1 = new VehicleContainer
        {
            Vehicle = new Car { Brand = "Toyota", Doors = 4 }
        };

        var obj2 = new VehicleContainer
        {
            Vehicle = new Car { Brand = "Honda", Doors = 4 } // Different brand
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Single(diffs);
        var diff = diffs[0];
        Assert.IsType<ValueNode>(diff.Leaf);
        var valueNode = (ValueNode)diff.Leaf;
        Assert.Equal("Brand", valueNode.PropertyName);
        Assert.Equal("Toyota", valueNode.CurrentValue);
        Assert.Equal("Honda", valueNode.OtherValue);
    }

    [Fact]
    public void Diff_PolymorphicProperty_DifferentDerivedTypes_ReportsDifference()
    {
        // Arrange - different derived types
        var obj1 = new VehicleContainer
        {
            Vehicle = new Car { Brand = "Toyota", Doors = 4 }
        };

        var obj2 = new VehicleContainer
        {
            Vehicle = new Motorcycle { Brand = "Honda", HasSidecar = false }
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert - should report type difference
        Assert.NotEmpty(diffs);
        // The exact format of the difference may vary, but there should be differences
    }

    [Fact]
    public void Diff_MultiLevelInheritance_FindsDifferences()
    {
        // Arrange
        var obj1 = new VehicleContainer
        {
            Vehicle = new SportsCar { Brand = "Ferrari", Doors = 2, TopSpeed = 320 }
        };

        var obj2 = new VehicleContainer
        {
            Vehicle = new SportsCar { Brand = "Ferrari", Doors = 2, TopSpeed = 300 } // Different TopSpeed
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Single(diffs);
        var diff = diffs[0];
        Assert.IsType<ValueNode>(diff.Leaf);
        var valueNode = (ValueNode)diff.Leaf;
        Assert.Equal("TopSpeed", valueNode.PropertyName);
        Assert.Equal(320, valueNode.CurrentValue);
        Assert.Equal(300, valueNode.OtherValue);
    }

    #endregion

    #region DifferencePath Tests

    [Fact]
    public void DifferencePath_ToString_ProducesReadableOutput()
    {
        // Arrange
        var obj1 = new FamilyTree
        {
            Name = "Root",
            LeftChild = new PersonState { Name = "Alice", Age = 10, Score = 85m }
        };

        var obj2 = new FamilyTree
        {
            Name = "Root",
            LeftChild = new PersonState { Name = "Alice", Age = 11, Score = 85m }
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Single(diffs);
        var pathString = diffs[0].ToString();
        Assert.NotEmpty(pathString);
        Assert.Contains("LeftChild", pathString);
        Assert.Contains("Age", pathString);
    }

    [Fact]
    public void DifferencePath_GetPath_ReturnsCompleteChain()
    {
        // Arrange
        var obj1 = new FamilyTree
        {
            Name = "Root",
            LeftChild = new PersonState { Name = "Alice", Age = 10, Score = 85m }
        };

        var obj2 = new FamilyTree
        {
            Name = "Root",
            LeftChild = new PersonState { Name = "Alice", Age = 11, Score = 85m }
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert
        Assert.Single(diffs);
        var path = diffs[0].GetPath().ToList();
        Assert.True(path.Count >= 2); // At least ReferenceNode -> ValueNode
        Assert.IsType<ReferenceNode>(path[0]);
        Assert.IsType<ValueNode>(path.Last());
    }

    #endregion

    #region Skip Diff Attribute Tests

    [Fact]
    public void Diff_WithSkipDiffAttribute_IgnoresProperty()
    {
        // Arrange
        var obj1 = new CachedData
        {
            ImportantValue = 42,
            CacheTimestamp = DateTime.UtcNow
        };

        var obj2 = new CachedData
        {
            ImportantValue = 42,
            CacheTimestamp = DateTime.UtcNow.AddDays(10) // Different but should be ignored
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert - should have no differences despite different CacheTimestamp
        Assert.Empty(diffs);
    }

    [Fact]
    public void Diff_WithSkipDiffAttribute_StillDetectsOtherDifferences()
    {
        // Arrange
        var obj1 = new CachedData
        {
            ImportantValue = 42,
            CacheTimestamp = DateTime.UtcNow
        };

        var obj2 = new CachedData
        {
            ImportantValue = 99, // Different and NOT skipped
            CacheTimestamp = DateTime.UtcNow.AddDays(10) // Different but skipped
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert - should detect ImportantValue difference but not CacheTimestamp
        Assert.Single(diffs);
        var diff = diffs[0];
        Assert.IsType<ValueNode>(diff.Leaf);
        var valueNode = (ValueNode)diff.Leaf;
        Assert.Equal("ImportantValue", valueNode.PropertyName);
        Assert.Equal(42, valueNode.CurrentValue);
        Assert.Equal(99, valueNode.OtherValue);
    }

    #endregion

    #region Complex Graph Tests

    [Fact]
    public void Diff_ComplexGraph_MultipleDifferences_FindsAll()
    {
        // Arrange - complex graph with differences at multiple levels
        var obj1 = new TreeNode
        {
            Value = 1,
            Children = new List<TreeNode>
            {
                new TreeNode
                {
                    Value = 10,
                    Children = new List<TreeNode>
                    {
                        new TreeNode { Value = 100 },
                        new TreeNode { Value = 200 }
                    }
                },
                new TreeNode
                {
                    Value = 20,
                    Children = new List<TreeNode>
                    {
                        new TreeNode { Value = 300 }
                    }
                }
            }
        };

        var obj2 = new TreeNode
        {
            Value = 2, // Different root value
            Children = new List<TreeNode>
            {
                new TreeNode
                {
                    Value = 10,
                    Children = new List<TreeNode>
                    {
                        new TreeNode { Value = 100 },
                        new TreeNode { Value = 201 } // Different nested value
                    }
                },
                new TreeNode
                {
                    Value = 20,
                    Children = new List<TreeNode>
                    {
                        new TreeNode { Value = 300 }
                    }
                }
            }
        };

        // Act
        var diffs = obj1.Diff(obj2).ToList();

        // Assert - should find both differences
        Assert.Equal(2, diffs.Count);
        Assert.Contains(diffs, d => d.Leaf is ValueNode vn && vn.CurrentValue?.Equals(1) == true && vn.OtherValue?.Equals(2) == true);
        Assert.Contains(diffs, d => d.Leaf is ValueNode vn && vn.CurrentValue?.Equals(200) == true && vn.OtherValue?.Equals(201) == true);
    }

    [Fact]
    public void Diff_LargeGraph_PerformsReasonably()
    {
        // Arrange - large graph
        TreeNode CreateLargeTree(int depth, int branches, int baseValue)
        {
            if (depth == 0)
                return new TreeNode { Value = baseValue };

            var children = new List<TreeNode>();
            for (int i = 0; i < branches; i++)
            {
                children.Add(CreateLargeTree(depth - 1, branches, baseValue * 10 + i));
            }

            return new TreeNode { Value = baseValue, Children = children };
        }

        var obj1 = CreateLargeTree(4, 3, 1); // 3^4 = 81 nodes
        var obj2 = CreateLargeTree(4, 3, 1);

        // Act
        var startTime = DateTime.UtcNow;
        var diffs = obj1.Diff(obj2).ToList();
        var elapsed = DateTime.UtcNow - startTime;

        // Assert
        Assert.Empty(diffs);
        Assert.True(elapsed.TotalSeconds < 5, "Diff operation should complete reasonably quickly");
    }

    #endregion
}


